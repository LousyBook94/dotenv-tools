"""Additional features for dotenv-tools.

This module contains the extra features mentioned in the roadmap:
- Auto-completion for shell integration
- .env template generation
- Environment diffing
- YAML/JSON export support
"""

import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

import click
import yaml

from .core import LoadDotenv, find_dotenv_file
from .parser import parse_file_to_dict


class DotenvExporter:
    """Export .env files to different formats."""

    def __init__(self, env_file: Path):
        self.env_file = env_file

    def export_to_json(self) -> str:
        """Export .env file to JSON format."""
        content = self.env_file.read_text(encoding='utf-8')
        variables = parse_file_to_dict(content)

        # Convert to JSON-serializable format
        json_data = {}
        for key, (op, value) in variables.items():
            json_data[key] = value

        return json.dumps(json_data, indent=2, ensure_ascii=False)

    def export_to_yaml(self) -> str:
        """Export .env file to YAML format."""
        content = self.env_file.read_text(encoding='utf-8')
        variables = parse_file_to_dict(content)

        # Convert to YAML-serializable format
        yaml_data = {}
        for key, (op, value) in variables.items():
            yaml_data[key] = value

        return yaml.dump(yaml_data, default_flow_style=False, allow_unicode=True)


class DotenvTemplate:
    """Generate .env templates."""

    @staticmethod
    def generate_template(
        variables: Optional[List[str]] = None,
        include_comments: bool = True,
        include_examples: bool = True
    ) -> str:
        """Generate a .env template.

        Args:
            variables: List of variable names to include
            include_comments: Whether to include helpful comments
            include_examples: Whether to include example values

        Returns:
            Generated template as string
        """
        if variables is None:
            variables = [
                'APP_NAME', 'APP_ENV', 'DEBUG', 'PORT',
                'DATABASE_URL', 'API_KEY', 'SECRET_KEY',
                'REDIS_URL', 'EMAIL_HOST', 'EMAIL_PORT',
                'EMAIL_USER', 'EMAIL_PASSWORD'
            ]

        template_lines = [
            "# Environment variables template",
            "# Generated by dotenv-tools",
            ""
        ]

        examples = {
            'APP_NAME': '"MyApplication"',
            'APP_ENV': '"development"',
            'DEBUG': 'true',
            'PORT': '3000',
            'DATABASE_URL': '"postgresql://user:password@localhost/dbname"',
            'API_KEY': '"your-api-key-here"',
            'SECRET_KEY': '"your-secret-key-here"',
            'REDIS_URL': '"redis://localhost:6379/0"',
            'EMAIL_HOST': '"smtp.gmail.com"',
            'EMAIL_PORT': '587',
            'EMAIL_USER': '"your-email@gmail.com"',
            'EMAIL_PASSWORD': '"your-email-password"'
        }

        descriptions = {
            'APP_NAME': 'Application name',
            'APP_ENV': 'Application environment (development, production, etc.)',
            'DEBUG': 'Enable debug mode',
            'PORT': 'Application port number',
            'DATABASE_URL': 'Database connection URL',
            'API_KEY': 'API authentication key',
            'SECRET_KEY': 'Application secret key',
            'REDIS_URL': 'Redis connection URL',
            'EMAIL_HOST': 'SMTP email server host',
            'EMAIL_PORT': 'SMTP email server port',
            'EMAIL_USER': 'Email username',
            'EMAIL_PASSWORD': 'Email password'
        }

        for var in variables:
            if include_comments and var in descriptions:
                template_lines.append(f"# {descriptions[var]}")

            if include_examples and var in examples:
                template_lines.append(f"{var}={examples[var]}")
            else:
                template_lines.append(f"{var}=")

            template_lines.append("")  # Empty line

        return "\n".join(template_lines)


class DotenvDiffer:
    """Compare different .env files or environments."""

    def __init__(self):
        self.parser = None

    def compare_files(self, file1: Path, file2: Path) -> Dict[str, Any]:
        """Compare two .env files.

        Args:
            file1: First .env file
            file2: Second .env file

        Returns:
            Dictionary with comparison results
        """
        content1 = file1.read_text(encoding='utf-8')
        content2 = file2.read_text(encoding='utf-8')

        vars1 = parse_file_to_dict(content1)
        vars2 = parse_file_to_dict(content2)

        keys1 = set(vars1.keys())
        keys2 = set(vars2.keys())

        common_keys = keys1 & keys2
        only_in_file1 = keys1 - keys2
        only_in_file2 = keys2 - keys1

        same_values = {}
        different_values = {}

        for key in common_keys:
            if vars1[key][1] == vars2[key][1]:  # Compare values (index 1)
                same_values[key] = vars1[key][1]
            else:
                different_values[key] = {
                    'file1': vars1[key][1],
                    'file2': vars2[key][1]
                }

        return {
            'common_variables': len(common_keys),
            'only_in_file1': {k: vars1[k][1] for k in only_in_file1},  # Get values
            'only_in_file2': {k: vars2[k][1] for k in only_in_file2},  # Get values
            'same_values': same_values,
            'different_values': different_values,
            'total_comparison': {
                'file1': len(keys1),
                'file2': len(keys2),
                'common': len(common_keys),
                'differences': len(different_values)
            }
        }

    def compare_with_env(self, file: Path) -> Dict[str, Any]:
        """Compare .env file with current environment.

        Args:
            file: .env file to compare

        Returns:
            Dictionary with comparison results
        """
        content = file.read_text(encoding='utf-8')
        env_vars = parse_file_to_dict(content)

        env_only = {}
        file_only = {}
        different = {}
        same = {}

        for key, (op, file_value) in env_vars.items():
            env_value = os.environ.get(key)

            if env_value is None:
                file_only[key] = file_value
            elif env_value == file_value:
                same[key] = file_value
            else:
                different[key] = {
                    'env': env_value,
                    'file': file_value
                }

        # Find variables only in environment (not in file)
        for env_key, env_value in os.environ.items():
            if env_key not in env_vars and not env_key.startswith('_'):
                env_only[env_key] = env_value

        return {
            'same': same,
            'different': different,
            'only_in_file': file_only,
            'only_in_env': env_only,
            'summary': {
                'total_env_vars': len(os.environ),
                'total_file_vars': len(env_vars),
                'matching': len(same),
                'differences': len(different),
                'file_only': len(file_only),
                'env_only': len(env_only)
            }
        }


class ShellCompleter:
    """Generate shell completion scripts."""

    @staticmethod
    def generate_bash_completion() -> str:
        """Generate bash completion script."""
        return '''#!/bin/bash
# Bash completion for dotenv-tools
_dotenv_tools_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts="load-dotenv unload-dotenv set-dotenv"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "--help --verbose --version" -- ${cur}) )
        return 0
    fi

    case "${prev}" in
        load-dotenv)
            COMPREPLY=( $(compgen -f -X "!*.env" -- ${cur}) )
            return 0
            ;;
        set-dotenv)
            if [[ ${cur} == -* ]] ; then
                COMPREPLY=( $(compgen -W "--file --remove --operator --edit --editor --list --verbose --help" -- ${cur}) )
                return 0
            fi
            ;;
    esac

    COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
}

complete -F _dotenv_tools_completion load-dotenv
complete -F _dotenv_tools_completion unload-dotenv
complete -F _dotenv_tools_completion set-dotenv
'''

    @staticmethod
    def generate_zsh_completion() -> str:
        """Generate zsh completion script."""
        return '''#!/usr/bin/env zsh
# Zsh completion for dotenv-tools

autoload -U compinit
compinit

typeset -A opt_args

_dotenv_tools() {
    local context curcontext="dotenv-tools" state line
    typeset -A val_args

    _arguments \\
        '(-h --help)'{-h,--help}'[show help]' \\
        '(-v --verbose)'{-v,--verbose}'[verbose output]' \\
        '1: :_dotenv_tools_commands' \\
        '*::arg:->args' && return 0

    case $state in
        args)
            case $words[1] in
                load-dotenv)
                    _arguments \\
                        '(-o --override)'{-o,--override}'[override existing variables]' \\
                        '1:env file:_files -g "*.env"' \\
                        ;;
                set-dotenv)
                    _arguments \\
                        '(-f --file)'{-f,--file}'[.env file]:file:_files' \\
                        '(-r --remove)'{-r,--remove}'[remove variable]' \\
                        '(-e --edit)'{-e,--edit}'[edit file]' \\
                        '(-l --list)'{-l,--list}'[list variables]' \\
                        '(-o --operator)'{-o,--operator}'[assignment operator]:operator:=': \\
                        '(-v --verbose)'{-v,--verbose}'[verbose output]' \\
                        ;;
            esac
            ;;
    esac
}

_dotenv_tools_commands() {
    local commands
    commands=(
        'load-dotenv:Load environment variables from .env file'
        'unload-dotenv:Remove loaded environment variables'
        'set-dotenv:Set or modify variables in .env file'
    )
    _describe 'commands' commands
}

_dotenv_tools "$@"
'''

    @staticmethod
    def generate_fish_completion() -> str:
        """Generate fish completion script."""
        return '''#!/usr/bin/env fish
# Fish completion for dotenv-tools

function __fish_use_subcommand
    set -l subcommands load-dotenv unload-dotenv set-dotenv
    for i in $subcommands
        if contains -- $i $argv
            return 1
        end
    end
    return 0
end

function __fish_dotenv_needs_command
    set -l cmd (commandline -opc)
    if [ (count $cmd) -eq 1 ]
        return 0
    end
    return 1
end

# load-dotenv
complete -c load-dotenv -n "__fish_dotenv_needs_command" -xa "load-dotenv"
complete -c load-dotenv -s o -l override -d "Override existing environment variables"
complete -c load-dotenv -s v -l verbose -d "Show detailed output"
complete -c load-dotenv -f -k -xa "env file" -d ".env file" -F

# unload-dotenv
complete -c unload-dotenv -n "__fish_dotenv_needs_command" -xa "unload-dotenv"
complete -c unload-dotenv -s f -l force -d "Unload without confirmation"
complete -c unload-dotenv -s v -l verbose -d "Show detailed output"

# set-dotenv
complete -c set-dotenv -n "__fish_dotenv_needs_command" -xa "set-dotenv"
complete -c set-dotenv -s f -l file -d ".env file"
complete -c set-dotenv -s r -l remove -d "Remove the specified variable"
complete -c set-dotenv -s e -l edit -d "Edit the .env file"
complete -c set-dotenv -s l -l list -d "List all variables"
complete -c set-dotenv -s o -l operator -d "Assignment operator"
complete -c set-dotenv -s v -l verbose -d "Show detailed output"
'''

    @staticmethod
    def generate_powershell_completion() -> str:
        """Generate PowerShell completion script."""
        return '''# PowerShell completion for dotenv-tools
Register-ArgumentCompleter -Native -CommandName 'load-dotenv', 'unload-dotenv', 'set-dotenv' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $script = [string]::Empty
    for ($i = 1; $i -lt $commandElements.Count; $i++) {
        $element = $commandElements[$i]
        if (($element -isnot [StringConstantExpressionAst]) -or
            ($element.StringConstantType -ne ([StringConstantType]::BareWord))) {
            break
        }
        $script += $element.Value
    }

    $completions = @(
        if ($wordToComplete.StartsWith('-')) {
            [System.Management.Automation.CompletionResult]::new(
                '--override', 'override', [CompletionResultType]::ParameterName, 'Override existing environment variables'
            )
            [System.Management.Automation.CompletionResult]::new(
                '--state-file', 'state-file', [CompletionResultType]::ParameterName, 'Path to state file'
            )
            [System.Management.Automation.CompletionResult]::new(
                '--verbose', 'verbose', [CompletionResultType]::ParameterName, 'Show detailed output'
            )
            [System.Management.Automation.CompletionResult]::new(
                '--help', 'help', [CompletionResultType]::ParameterName, 'Show help message'
            )
        }
        else {
            [System.Management.Automation.CompletionResult]::new(
                'load-dotenv', 'load-dotenv', [CompletionResultType]::ParameterValue, 'Load environment variables from .env file'
            )
            [System.Management.Automation.CompletionResult]::new(
                'unload-dotenv', 'unload-dotenv', [CompletionResultType]::ParameterValue, 'Remove loaded environment variables'
            )
            [System.Management.Automation.CompletionResult]::new(
                'set-dotenv', 'set-dotenv', [CompletionResultType]::ParameterValue, 'Set or modify variables in .env file'
            )
        }
    )

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemType
}'''



# CLI Commands
def export_dotenv(file: Path, format: str, output: Optional[Path], verbose: bool):
    """Export .env file to different formats."""
    try:
        exporter = DotenvExporter(file)

        if format == 'json':
            content = exporter.export_to_json()
            output_format = 'JSON'
        elif format == 'yaml':
            content = exporter.export_to_yaml()
            output_format = 'YAML'
        else:
            raise click.ClickException(f"Unsupported format: {format}")

        if output:
            output.write_text(content, encoding='utf-8')
            if verbose:
                click.echo(f"[OK] Exported {output_format} to {output}")
        else:
            click.echo(content)

    except Exception as e:
        raise click.ClickException(f"Error exporting: {e}")


def generate_dotenv_template(
    output: Optional[Path],
    variables: Optional[List[str]],
    no_comments: bool,
    no_examples: bool,
    verbose: bool
):
    """Generate .env template."""
    try:
        template = DotenvTemplate.generate_template(
            variables=variables,
            include_comments=not no_comments,
            include_examples=not no_examples
        )

        if output:
            output.write_text(template, encoding='utf-8')
            if verbose:
                click.echo(f"[OK] Generated template to {output}")
        else:
            click.echo(template)

    except Exception as e:
        raise click.ClickException(f"Error generating template: {e}")


def compare_dotenv_files(
    file1: Path,
    file2: Optional[Path],
    format: str,
    output: Optional[Path],
    verbose: bool
):
    """Compare .env files or with environment."""
    try:
        differ = DotenvDiffer()

        if file2:
            result = differ.compare_files(file1, file2)
            comparison_type = f"between {file1.name} and {file2.name}"
        else:
            result = differ.compare_with_env(file1)
            comparison_type = f"between {file1.name} and current environment"

        if format == 'json':
            output_content = json.dumps(result, indent=2, ensure_ascii=False)
        elif format == 'text':
            output_content = format_diff_text(result)
        else:
            raise click.ClickException(f"Unsupported format: {format}")

        if output:
            output.write_text(output_content, encoding='utf-8')
            if verbose:
                click.echo(f"[OK] Saved comparison to {output}")
        else:
            click.echo(output_content)

    except Exception as e:
        raise click.ClickException(f"Error comparing: {e}")


def format_diff_text(result: Dict[str, Any]) -> str:
    """Format diff result as human-readable text."""
    lines = ["Environment Comparison Results", "=" * 40, ""]

    if 'total_comparison' in result:
        # File comparison
        lines.append(f"File 1 variables: {result['total_comparison']['file1']}")
        lines.append(f"File 2 variables: {result['total_comparison']['file2']}")
        lines.append(f"Common variables: {result['total_comparison']['common']}")
        lines.append(f"Different values: {result['total_comparison']['differences']}")
        lines.append("")

        if result['only_in_file1']:
            lines.append("Only in file 1:")
            for key, value in result['only_in_file1'].items():
                lines.append(f"  {key} = {value}")
            lines.append("")

        if result['only_in_file2']:
            lines.append("Only in file 2:")
            for key, value in result['only_in_file2'].items():
                lines.append(f"  {key} = {value}")
            lines.append("")

        if result['different_values']:
            lines.append("Different values:")
            for key, values in result['different_values'].items():
                lines.append(f"  {key}:")
                lines.append(f"    file1: {values['file1']}")
                lines.append(f"    file2: {values['file2']}")
    else:
        # Environment comparison
        summary = result['summary']
        lines.append(f"Matching variables: {summary['matching']}")
        lines.append(f"Different values: {summary['differences']}")
        lines.append(f"Only in .env file: {summary['file_only']}")
        lines.append(f"Only in environment: {summary['env_only']}")
        lines.append("")

        if result['different']:
            lines.append("Different values:")
            for key, values in result['different'].items():
                lines.append(f"  {key}:")
                lines.append(f"    environment: {values['env']}")
                lines.append(f"    .env file: {values['file']}")

    return "\n".join(lines)


def install_shell_completion(shell: str, verbose: bool):
    """Install shell completion for dotenv-tools."""
    try:
        completer = ShellCompleter()

        if shell.lower() == 'bash':
            script = completer.generate_bash_completion()
        elif shell.lower() == 'zsh':
            script = completer.generate_zsh_completion()
        elif shell.lower() == 'fish':
            script = completer.generate_fish_completion()
        elif shell.lower() in ['powershell', 'pwsh']:
            script = completer.generate_powershell_completion()
        else:
            raise click.ClickException(f"Unsupported shell: {shell}")

        # Determine completion file location
        shell_name = shell.lower()
        completion_file = None

        if shell_name == 'bash':
            # Fix for Git Bash on Windows - use user home directory
            if os.name == 'nt':  # Windows
                # Check if we're in Git Bash/MINGW - use user home directory for compatibility
                if 'MSYSTEM' in os.environ or 'MINGW' in os.sys.platform:
                    # Git Bash on Windows: use ~/.bash_completion.d in user's home
                    # Use POSIX path relative to home for cross-platform compatibility
                    home = Path.home()
                    completion_file = home / '.bash_completion.d' / 'dotenv-tools'
                else:
                    # Regular Windows - use user profile
                    completion_file = Path.home() / '.bash_completion.d' / 'dotenv-tools'
            else:
                # Linux/macOS
                if Path('/etc/bash_completion.d').exists():
                    completion_file = Path('/etc/bash_completion.d/dotenv-tools')
                else:
                    completion_file = Path.home() / '.bash_completion.d' / 'dotenv-tools'

        elif shell_name == 'zsh':
            completion_file = Path.home() / '.zfunc' / '_dotenv-tools'

        elif shell_name == 'fish':
            completion_file = Path.home() / '.config' / 'fish' / 'completions' / 'dotenv-tools.fish'

        elif shell_name in ['powershell', 'pwsh']:
            # PowerShell - install to user profile
            profile_dir = Path.home() / 'Documents' / 'PowerShell'
            if not profile_dir.exists():
                # Try Documents\WindowsPowerShell for older PowerShell
                profile_dir = Path.home() / 'Documents' / 'WindowsPowerShell'
            completion_file = profile_dir / 'dotenv-tools-completion.ps1'

        # Create directory if needed
        if completion_file:
            completion_file.parent.mkdir(parents=True, exist_ok=True)

            # Write completion script
            completion_file.write_text(script, encoding='utf-8')
            if shell_name in ['bash', 'zsh', 'fish']:
                completion_file.chmod(0o755)

            if verbose:
                click.echo(f"[OK] Installed {shell} completion to {completion_file}")

            # Provide setup instructions
            if shell_name == 'bash':
                if 'MSYSTEM' in os.environ or 'MINGW' in os.sys.platform:
                    # Git Bash/MINGW - use POSIX path for display
                    posix_path = completion_file.as_posix() if hasattr(completion_file, 'as_posix') else str(completion_file)
                    click.echo(f"\nCompletion installed to: {completion_file}")
                    click.echo("\nTo activate in Git Bash, add this line to your ~/.bashrc:")
                    click.echo(f'  source "{posix_path}"')
                elif str(completion_file).startswith('/etc/'):
                    # System-wide installation
                    click.echo(f"\nCompletion installed to: {completion_file}")
                    click.echo("Source it in your ~/.bashrc to activate:")
                    click.echo(f'  source "{completion_file}"')
                else:
                    # User installation
                    click.echo(f"\nCompletion installed to: {completion_file}")
                    click.echo("Source it in your ~/.bashrc to activate:")
                    click.echo(f'  source "{completion_file}"')

            elif shell_name == 'zsh':
                click.echo(f"\nCompletion installed to: {completion_file}")
                click.echo(f"\nAdd to your ~/.zshrc:")
                click.echo(f'  fpath=({completion_file.parent} $fpath)')
                click.echo("Then restart your shell or run 'autoload -U compinit; compinit'")

            elif shell_name == 'fish':
                click.echo(f"\nCompletion installed to: {completion_file}")
                click.echo("Restart your shell to activate completion.")

            elif shell_name in ['powershell', 'pwsh']:
                click.echo(f"\nCompletion installed to: {completion_file}")
                click.echo("\nTo activate in PowerShell, add this line to your profile:")
                click.echo(f'  . "{completion_file}"')
                click.echo("\nOr run it directly in the current session:")
                click.echo(f'  . "{completion_file}"')

    except Exception as e:
        raise click.ClickException(f"Error installing completion: {e}")
